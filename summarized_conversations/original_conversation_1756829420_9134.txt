{'role': 'assistant', 'content': 'Let\'s create a simple noise texture generator script that we can use to generate a noise texture for our shader:\n\n<function_calls>\n<create-file file_path="eternis33_prototype/src/tools/generate_noise_texture.py">\n#!/usr/bin/env python3\n"""\nNoise Texture Generator for Eternis-33\nCreates a noise texture for use with the Prism shader\n"""\n\nimport numpy as np\nfrom PIL import Image\nimport os\n\ndef generate_perlin_noise_2d(shape, res):\n    """Generate a 2D perlin noise texture"""\n    def f(t):\n        return 6*t**5 - 15*t**4 + 10*t**3\n    \n    delta = (res[0] / shape[0], res[1] / shape[1])\n    d = (shape[0] // res[0], shape[1] // res[1])\n    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]].transpose(1, 2, 0) % 1\n    \n    # Gradients\n    angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)\n    gradients = np.dstack((np.cos(angles), np.sin(angles)))\n    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)\n    \n    g00 = gradients[:-d[0], :-d[1]]\n    g10 = gradients[d[0]:, :-d[1]]\n    g01 = gradients[:-d[0], d[1]:]\n    g11 = gradients[d[0]:, d[1]:]\n    \n    # Ramps\n    n00 = np.sum(grid * g00, 2)\n    n10 = np.sum(np.dstack((grid[:, :, 0]-1, grid[:, :, 1])) * g10, 2)\n    n01 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1]-1)) * g01, 2)\n    n11 = np.sum(np.dstack((grid[:, :, 0]-1, grid[:, :, 1]-1)) * g11, 2)\n    \n    # Interpolation\n    t = f(grid)\n    n0 = n00*(1-t[:, :, 0]) + t[:, :, 0]*n10\n    n1 = n01*(1-t[:, :, 0]) + t[:, :, 0]*n11\n    \n    return np.sqrt(2)*((1-t[:, :, 1])*n0 + t[:, :, 1]*n1)\n\ndef generate_fractal_noise_2d(shape, res, octaves=1, persistence=0.5):\n    """Generate a 2D fractal noise texture by layering perlin noise"""\n    noise = np.zeros(shape)\n    frequency = 1\n    amplitude = 1.0\n    \n    # Add successively smaller, higher-frequency terms\n    for _ in range(octaves):\n        noise += amplitude * generate_perlin_noise_2d(shape, (res[0] * frequency, res[1] * frequency))\n        frequency *= 2\n        amplitude *= persistence\n    \n    # Normalize to [0, 1]\n    noise = (noise - np.min(noise)) / (np.max(noise) - np.min(noise))\n    return noise\n\ndef save_noise_texture(noise, filename):\n    """Save the noise array as an image"""\n    # Scale to 0-255 and convert to uint8\n    img_data = (noise * 255).astype(np.uint8)\n    img = Image.fromarray(img_data, mode=\'L\')\n    img.save(filename)\n    print(f"Saved noise texture to {filename}")\n\ndef main():\n    # Create output directory if it doesn\'t exist\n    output_dir = "../assets/textures/noise"\n    os.makedirs(output_dir, exist_ok=True)\n    \n    # Generate noise textures\n    print("Generating noise textures...")\n    \n    # Generate a basic noise texture\n    basic_noise = generate_perlin_noise_2d((256, 256), (8, 8))\n    save_noise_texture(basic_noise, os.path.join(output_dir, "basic_noise.png"))\n    \n    # Generate a fractal noise texture\n    fractal_noise = generate_fractal_noise_2d((256, 256), (4, 4), octaves=5, persistence=0.5)\n    save_noise_texture(fractal_noise, os.path.join(output_dir, "fractal_noise.png"))\n    \n    # Generate a shimmer noise texture (higher frequency)\n    shimmer_noise = generate_fractal_noise_2d((256, 256), (8, 8), octaves=3, persistence=0.7)\n    save_noise_texture(shimmer_noise, os.path.join(output_dir, "shimmer_noise.png"))\n    \n    print("Noise texture generation complete.")\n\nif __name__ == "__main__":\n    main()\n</create-file>\n</function_calls>', 'tool_calls': None}